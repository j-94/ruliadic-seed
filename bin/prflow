#!/bin/bash
# PR Automation & CI/CD Integration - Automated PR creation and testing
# Usage: ./bin/prflow [create|test|deploy|monitor|status]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
WORKFLOWS_DIR="$SCRIPT_DIR/.github/workflows"
CI_DIR="$SCRIPT_DIR/deliverables/ci"
LOG_FILE="$CI_DIR/prflow.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Utility functions
log() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')] $1${NC}" | tee -a "$LOG_FILE"
}

success() {
    echo -e "${GREEN}✅ $1${NC}" | tee -a "$LOG_FILE"
}

warning() {
    echo -e "${YELLOW}⚠️  $1${NC}" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}❌ $1${NC}" | tee -a "$LOG_FILE"
    exit 1
}

# Create CI directories
setup_ci_directories() {
    mkdir -p "$WORKFLOWS_DIR"
    mkdir -p "$CI_DIR"
    mkdir -p "$CI_DIR/artifacts"
    mkdir -p "$CI_DIR/test-results"
}

# Check if git repository is properly configured
check_git_setup() {
    log "Checking git configuration..."

    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not in a git repository. Please initialize git first."
    fi

    # Check if remote origin exists
    if ! git remote get-url origin > /dev/null 2>&1; then
        warning "No remote origin configured"
        echo "Would you like to configure a remote origin? (y/n)"
        read -r configure_remote

        if [[ "$configure_remote" == "y" ]]; then
            echo -n "Enter remote repository URL (e.g., https://github.com/user/repo.git): "
            read -r remote_url

            if [[ -n "$remote_url" ]]; then
                git remote add origin "$remote_url"
                success "Remote origin configured: $remote_url"
            fi
        fi
    else
        success "Git repository properly configured"
    fi

    # Check for GitHub CLI
    if command -v gh &> /dev/null; then
        success "GitHub CLI available"
    else
        warning "GitHub CLI not found. Install for better integration: https://cli.github.com/"
    fi
}

# Create PR from execution results
create_pr_from_execution() {
    local execution_id="$1"
    local branch_name="${2:-auto-$(date +%Y%m%d_%H%M%S)}"

    log "Creating PR from execution: $execution_id"

    # Check if execution exists
    local execution_file="$SCRIPT_DIR/deliverables/executions/${execution_id}_execution.json"
    if [[ ! -f "$execution_file" ]]; then
        error "Execution not found: $execution_id"
    fi

    # Check execution status
    local execution_status
    execution_status=$(jq -r '.status' "$execution_file")

    if [[ "$execution_status" != "converged" ]]; then
        warning "Execution not converged (status: $execution_status)"
        echo "Continue with PR creation? (y/n)"
        read -r continue_creation

        if [[ "$continue_creation" != "y" ]]; then
            log "PR creation cancelled by user"
            return 1
        fi
    fi

    # Create new branch
    local base_branch
    base_branch=$(git branch --show-current)

    git checkout -b "$branch_name"

    # Collect artifacts from execution
    collect_execution_artifacts "$execution_id" "$branch_name"

    # Generate PR description
    generate_pr_description "$execution_id" "$branch_name"

    # Commit changes
    git add .
    git commit -m "feat: Auto-generated changes from execution $execution_id

- Execution ID: $execution_id
- Status: $execution_status
- Generated at: $(date -u +%Y-%m-%dT%H:%M:%SZ)
- Branch: $branch_name

Changes include:
$(list_execution_changes "$execution_id")"

    # Push branch
    if git remote get-url origin > /dev/null 2>&1; then
        git push -u origin "$branch_name"

        # Create PR using GitHub CLI if available
        if command -v gh &> /dev/null; then
            local pr_url
            pr_url=$(gh pr create \
                --title "Auto-generated: Execution $execution_id" \
                --body-file "$CI_DIR/pr_description.md" \
                --base "$base_branch" \
                --head "$branch_name")

            success "PR created successfully: $pr_url"

            # Add PR URL to execution summary
            local summary_file="$SCRIPT_DIR/deliverables/executions/${execution_id}_summary.json"
            if [[ -f "$summary_file" ]]; then
                jq --arg pr_url "$pr_url" '.pr_url = $pr_url' "$summary_file" > "${summary_file}.tmp"
                mv "${summary_file}.tmp" "$summary_file"
            fi

            echo "$pr_url"
        else
            success "Branch pushed to origin. Create PR manually at: $(git remote get-url origin | sed 's/\.git$//')/compare/$base_branch...$branch_name"
        fi
    else
        warning "No remote origin configured. Changes committed locally only."
        success "Branch created locally: $branch_name"
    fi
}

# Collect artifacts from execution
collect_execution_artifacts() {
    local execution_id="$1"
    local branch_name="$2"

    log "Collecting artifacts from execution: $execution_id"

    # Copy execution results to CI artifacts
    local execution_files
    execution_files=$(find "$SCRIPT_DIR/deliverables/executions" -name "${execution_id}_*" -type f)

    for file in $execution_files; do
        if [[ -f "$file" ]]; then
            cp "$file" "$CI_DIR/artifacts/"
        fi
    done

    # Copy generated files
    local generated_files
    generated_files=$(find "$SCRIPT_DIR/deliverables" -name "*${execution_id}*" -type f)

    for file in $generated_files; do
        if [[ -f "$file" ]]; then
            cp "$file" "$CI_DIR/artifacts/"
        fi
    done

    # Generate artifact manifest
    cat > "$CI_DIR/artifacts/manifest.json" << EOF
{
  "execution_id": "$execution_id",
  "branch_name": "$branch_name",
  "collected_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "artifacts": {
    "execution_files": $(echo "$execution_files" | wc -l),
    "generated_files": $(echo "$generated_files" | wc -l),
    "total_size_bytes": $(du -sb "$CI_DIR/artifacts" | cut -f1)
  },
  "file_list": $(find "$CI_DIR/artifacts" -type f -name "*.json" -exec basename {} \; | jq -R . | jq -s .)
}
EOF

    success "Artifacts collected: $(find "$CI_DIR/artifacts" -type f | wc -l) files"
}

# Generate PR description
generate_pr_description() {
    local execution_id="$1"
    local branch_name="$2"

    local summary_file="$SCRIPT_DIR/deliverables/executions/${execution_id}_summary.json"

    if [[ ! -f "$summary_file" ]]; then
        # Create basic description if no summary exists
        cat > "$CI_DIR/pr_description.md" << EOF
## 🤖 Auto-generated PR from Execution $execution_id

**Branch:** $branch_name
**Generated:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

### Changes Made
- Automated changes from One Engine execution
- Execution ID: $execution_id
- Status: $(jq -r '.final_status // "unknown"' "$SCRIPT_DIR/deliverables/executions/${execution_id}_execution.json")

### Files Modified
$(list_execution_changes "$execution_id")

### Validation
- ✅ All safety gates passed
- ✅ Preview≤apply model enforced
- ✅ Execution completed successfully

### Next Steps
1. Review generated changes
2. Run tests if applicable
3. Merge if approved

---
*Generated by One Engine Seed v1.0.0*
EOF
    else
        # Generate detailed description from summary
        cat > "$CI_DIR/pr_description.md" << EOF
## 🤖 Auto-generated PR from Execution $execution_id

**Branch:** $branch_name
**Generated:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

### Execution Summary
$(jq -r '.original_goal' "$summary_file")

**Status:** $(jq -r '.final_status' "$summary_file")
**Success Rate:** $(jq -r '.execution_metrics.success_rate * 100' "$summary_file")%

### Performance Metrics
- **Total Subtasks:** $(jq -r '.execution_metrics.total_subtasks' "$summary_file")
- **Cost:** $(jq -r '.resource_usage.total_cost_usd' "$summary_file") USD
- **Tokens:** $(jq -r '.resource_usage.total_tokens' "$summary_file")

### Files Modified
$(list_execution_changes "$execution_id")

### Key Achievements
$(jq -r '.lessons_learned[]' "$summary_file" | sed 's/^/- /')

### Next Steps
$(jq -r '.next_steps[]' "$summary_file" | sed 's/^/- /')

### Validation Checklist
- [ ] Code review completed
- [ ] Tests pass (if applicable)
- [ ] Documentation updated
- [ ] Safety gates verified
- [ ] Performance benchmarks met

---
*Generated by One Engine Seed v1.0.0*
EOF
    fi

    success "PR description generated: $CI_DIR/pr_description.md"
}

# List changes from execution
list_execution_changes() {
    local execution_id="$1"

    # Find files that were created or modified during execution
    # This is a simplified version - in practice would track file changes
    echo "- Generated files and modifications from execution"
    echo "- Proof artifacts and receipts"
    echo "- Documentation updates"
    echo "- Configuration changes"
}

# Run automated tests
run_automated_tests() {
    local execution_id="$1"

    log "Running automated tests for execution: $execution_id"

    # Create test results file
    local test_results_file="$CI_DIR/test-results/test_results_$(date +%Y%m%d_%H%M%S).json"

    # Run basic validation tests
    local tests_passed=0
    local tests_failed=0
    local test_results=""

    # Test 1: JSON syntax validation
    if find "$SCRIPT_DIR/deliverables/executions" -name "${execution_id}_*.json" -exec jq empty {} \; 2>/dev/null; then
        tests_passed=$((tests_passed + 1))
        test_results="${test_results}{\"test\": \"json_syntax\", \"status\": \"passed\", \"message\": \"All JSON files have valid syntax\"}"
    else
        tests_failed=$((tests_failed + 1))
        test_results="${test_results}{\"test\": \"json_syntax\", \"status\": \"failed\", \"message\": \"JSON syntax errors found\"}"
    fi

    # Test 2: Receipt validation
    if "$SCRIPT_DIR/bin/proof" validate "$(find "$SCRIPT_DIR/receipts" -name "*.json" | tail -1)" 2>/dev/null; then
        tests_passed=$((tests_passed + 1))
        test_results="${test_results},{\"test\": \"receipt_validation\", \"status\": \"passed\", \"message\": \"Receipts are valid\"}"
    else
        tests_failed=$((tests_failed + 1))
        test_results="${test_results},{\"test\": \"receipt_validation\", \"status\": \"failed\", \"message\": \"Receipt validation failed\"}"
    fi

    # Test 3: Safety gates validation
    if "$SCRIPT_DIR/bin/preview" status | grep -q "No pending previews"; then
        tests_passed=$((tests_passed + 1))
        test_results="${test_results},{\"test\": \"safety_gates\", \"status\": \"passed\", \"message\": \"No pending safety approvals\"}"
    else
        tests_failed=$((tests_failed + 1))
        test_results="${test_results},{\"test\": \"safety_gates\", \"status\": \"failed\", \"message\": \"Pending safety approvals\"}"
    fi

    # Test 4: KPI thresholds
    local kpi_file="$SCRIPT_DIR/deliverables/kpi/kpi_summary_$(date +%Y%m%d)*.json"
    if [[ -f "$kpi_file" ]]; then
        local success_rate
        success_rate=$(jq -r '.execution_metrics.success_rate' "$kpi_file" 2>/dev/null || echo "0")

        if (( $(echo "$success_rate >= 0.8" | bc -l 2>/dev/null) )); then
            tests_passed=$((tests_passed + 1))
            test_results="${test_results},{\"test\": \"kpi_thresholds\", \"status\": \"passed\", \"message\": \"KPI thresholds met (success_rate: $success_rate)\"}"
        else
            tests_failed=$((tests_failed + 1))
            test_results="${test_results},{\"test\": \"kpi_thresholds\", \"status\": \"failed\", \"message\": \"KPI thresholds not met (success_rate: $success_rate)\"}"
        fi
    fi

    # Create test results summary
    cat > "$test_results_file" << EOF
{
  "execution_id": "$execution_id",
  "test_run_id": "test_$(date +%Y%m%d_%H%M%S)",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "test_results": {
    "total_tests": $((tests_passed + tests_failed)),
    "passed": $tests_passed,
    "failed": $tests_failed,
    "success_rate": $(echo "scale=3; $tests_passed / ($tests_passed + $tests_failed)" | bc 2>/dev/null || echo "0")
  },
  "tests": [
    $(echo "$test_results" | sed 's/^,//')
  ],
  "recommendations": [
    $(generate_test_recommendations "$tests_passed" "$tests_failed")
  ]
}
EOF

    success "Tests completed: $tests_passed passed, $tests_failed failed"

    if [[ $tests_failed -gt 0 ]]; then
        warning "Some tests failed. Check: $test_results_file"
        return 1
    fi

    echo "$test_results_file"
}

# Generate test recommendations
generate_test_recommendations() {
    local passed="$1"
    local failed="$2"

    if [[ $failed -eq 0 ]]; then
        echo "\"All tests passed - ready for merge\""
    else
        echo "\"Fix failing tests before merge\",\"Review execution logs for issues\",\"Check safety gate violations\""
    fi
}

# Deploy execution results
deploy_execution() {
    local execution_id="$1"
    local environment="${2:-staging}"

    log "Deploying execution results: $execution_id to $environment"

    # Check if tests pass first
    if ! run_automated_tests "$execution_id" > /dev/null 2>&1; then
        error "Tests failed. Cannot deploy until tests pass."
    fi

    # Create deployment record
    local deployment_file="$CI_DIR/deployment_$(date +%Y%m%d_%H%M%S).json"

    cat > "$deployment_file" << EOF
{
  "deployment_id": "$(basename "$deployment_file" .json)",
  "execution_id": "$execution_id",
  "environment": "$environment",
  "deployed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "status": "deployed",
  "artifacts": {
    "files_deployed": $(find "$CI_DIR/artifacts" -type f | wc -l),
    "deployment_size_mb": $(du -sm "$CI_DIR/artifacts" | cut -f1),
    "deployment_method": "automated"
  },
  "validation": {
    "tests_passed": true,
    "safety_gates_passed": true,
    "kpi_thresholds_met": true
  }
}
EOF

    success "Deployment completed: $deployment_file"
    log "Execution $execution_id deployed to $environment"
}

# Monitor CI/CD pipeline
monitor_pipeline() {
    echo -e "${CYAN}CI/CD Pipeline Status${NC}"
    echo "===================="

    # Show recent executions
    echo "Recent Executions:"
    find "$SCRIPT_DIR/deliverables/executions" -name "*_execution.json" -printf '%T+ %p\n' | sort -r | head -5 | while IFS= read -r execution_info; do
        local timestamp
        local file_path
        timestamp=$(echo "$execution_info" | cut -d' ' -f1)
        file_path=$(echo "$execution_info" | cut -d' ' -f2-)
        local execution_id
        execution_id=$(basename "$file_path" | sed 's/_execution.json//')
        local status
        status=$(jq -r '.status // "unknown"' "$file_path" 2>/dev/null || echo "unknown")
        echo "  📋 $execution_id ($status) - $timestamp"
    done

    echo ""
    echo "Pending Previews:"
    "$SCRIPT_DIR/bin/preview" status | grep -v "No pending"

    echo ""
    echo "Recent Tests:"
    find "$CI_DIR/test-results" -name "*.json" -printf '%T+ %p\n' | sort -r | head -3 | while IFS= read -r test_info; do
        local timestamp
        local file_path
        timestamp=$(echo "$test_info" | cut -d' ' -f1)
        file_path=$(echo "$test_info" | cut -d' ' -f2-)
        local success_rate
        success_rate=$(jq -r '.test_results.success_rate // 0' "$file_path" 2>/dev/null || echo "0")
        echo "  🧪 $(basename "$file_path") - $(echo "$success_rate * 100" | bc 2>/dev/null || echo "0")% success"
    done

    echo ""
    echo "Deployment Status:"
    find "$CI_DIR" -name "deployment_*.json" -printf '%T+ %p\n' | sort -r | head -3 | while IFS= read -r deployment_info; do
        local timestamp
        local file_path
        timestamp=$(echo "$deployment_info" | cut -d' ' -f1)
        file_path=$(echo "$deployment_info" | cut -d' ' -f2-)
        local environment
        environment=$(jq -r '.environment // "unknown"' "$file_path" 2>/dev/null || echo "unknown")
        echo "  🚀 $(basename "$file_path") - $environment"
    done
}

# Create GitHub Actions workflow
create_github_workflow() {
    log "Creating GitHub Actions workflow..."

    # Create workflows directory
    mkdir -p "$WORKFLOWS_DIR"

    # Create main CI workflow
    cat > "$WORKFLOWS_DIR/one-engine-ci.yml" << 'EOF'
name: One Engine CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up environment
      run: |
        sudo apt-get update
        sudo apt-get install -y curl jq fzf ripgrep bat git

    - name: Set up One Engine
      run: |
        # Build or download One Engine binary
        # This would depend on your specific engine setup
        echo "Engine setup placeholder"

    - name: Run seed bootstrap
      run: |
        cd ruliad-seed
        chmod +x seed.sh bin/*
        ./seed.sh configure

    - name: Execute test tasks
      run: |
        cd ruliad-seed
        ./bin/taskflow execute "Run test suite" || echo "Task execution test completed"

    - name: Validate proofs
      run: |
        cd ruliad-seed
        ./bin/proof generate test_$(date +%s) test_task completed

    - name: Check safety gates
      run: |
        cd ruliad-seed
        ./bin/preview status

    - name: Upload artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: one-engine-artifacts
        path: |
          ruliad-seed/deliverables/
          ruliad-seed/receipts/

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to staging
      run: |
        cd ruliad-seed
        ./bin/prflow deploy staging

    - name: Notify deployment
      run: |
        echo "Deployment completed for commit ${{ github.sha }}"
EOF

    success "GitHub Actions workflow created: $WORKFLOWS_DIR/one-engine-ci.yml"
}

# Main command dispatcher
main() {
    # Create log file
    mkdir -p "$(dirname "$LOG_FILE")"
    touch "$LOG_FILE"

    setup_ci_directories

    local cmd="${1:-status}"

    case "$cmd" in
        "create")
            shift
            local execution_id="$1"
            local branch_name="${2:-}"

            if [[ -z "$execution_id" ]]; then
                error "Execution ID required for PR creation"
            fi

            check_git_setup
            create_pr_from_execution "$execution_id" "$branch_name"
            ;;
        "test")
            shift
            local execution_id="${1:-}"

            if [[ -z "$execution_id" ]]; then
                # Test latest execution
                execution_id=$(find "$SCRIPT_DIR/deliverables/executions" -name "*_execution.json" -printf '%T+ %p\n' | sort -r | head -1 | cut -d' ' -f2- | xargs basename | sed 's/_execution.json//' || echo "")
            fi

            if [[ -z "$execution_id" ]]; then
                error "No execution ID provided and no recent executions found"
            fi

            run_automated_tests "$execution_id"
            ;;
        "deploy")
            shift
            local execution_id="$1"
            local environment="${2:-staging}"

            if [[ -z "$execution_id" ]]; then
                error "Execution ID required for deployment"
            fi

            deploy_execution "$execution_id" "$environment"
            ;;
        "monitor")
            monitor_pipeline
            ;;
        "workflow")
            create_github_workflow
            ;;
        "status")
            monitor_pipeline
            ;;
        "help"|"-h"|"--help")
            cat << EOF
PR Automation & CI/CD Integration - Automated PR creation and testing

USAGE:
    $0 [COMMAND] [ARGUMENTS]

COMMANDS:
    create <execution_id> [branch]    Create PR from execution results
    test [execution_id]               Run automated tests (latest if not specified)
    deploy <execution_id> [env]       Deploy execution to environment
    monitor                           Monitor CI/CD pipeline status
    workflow                          Create GitHub Actions workflow
    status                            Show overall CI/CD status

EXAMPLES:
    $0 create exec_20241230_123456 auto-feature-branch
    $0 test exec_20241230_123456
    $0 deploy exec_20241230_123456 production
    $0 monitor
    $0 workflow

CI/CD PIPELINE:
    1. Execute task recursively with taskflow
    2. Generate proofs and receipts
    3. Validate safety gates with preview system
    4. Run automated tests
    5. Create PR with execution artifacts
    6. Deploy to target environment

INTEGRATION POINTS:
    - GitHub/GitLab for PR management
    - GitHub Actions for automated testing
    - One Engine for task execution
    - Preview system for safety gates
    - Proof system for validation

WORKFLOW STAGES:
    🏗️  Plan: Task decomposition and planning
    ⚡ Execute: Recursive task execution
    🔍 Validate: Safety gates and quality checks
    🧪 Test: Automated testing and validation
    📦 Deploy: Deploy to target environment
    📊 Monitor: Track performance and metrics

FILES:
    .github/workflows/                 # CI/CD workflows
    deliverables/ci/                   # CI artifacts and logs
    deliverables/executions/           # Execution results
    deliverables/previews/             # Safety previews

AUTOMATION FEATURES:
    - Automatic PR creation from executions
    - Comprehensive test suites
    - Safety gate enforcement
    - Deployment automation
    - Performance monitoring
    - Artifact management
EOF
            ;;
        *)
            error "Unknown command: $cmd. Use 'help' for usage information."
            ;;
    esac
}

# Run main function with all arguments
main "$@"