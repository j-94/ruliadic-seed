#!/bin/bash
# Previewâ‰¤Apply Safety Model - Preview all actions before execution
# Usage: ./bin/preview [preview|apply|approve|reject|status] <execution_id>

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
PREVIEWS_DIR="$SCRIPT_DIR/deliverables/previews"
APPROVALS_DIR="$SCRIPT_DIR/deliverables/approvals"
LOG_FILE="$DELIVERABLES_DIR/preview.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Risk levels and their properties
declare -A RISK_LEVELS=(
    ["low"]="ðŸŸ¢:Safe to auto-approve:10:60"
    ["medium"]="ðŸŸ¡:Requires review:5:300"
    ["high"]="ðŸŸ :Requires approval:1:900"
    ["critical"]="ðŸ”´:Requires human oversight:0:infinite"
)

# Utility functions
log() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')] $1${NC}" | tee -a "$LOG_FILE"
}

success() {
    echo -e "${GREEN}âœ… $1${NC}" | tee -a "$LOG_FILE"
}

warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}âŒ $1${NC}" | tee -a "$LOG_FILE"
    exit 1
}

# Create preview directories
setup_preview_directories() {
    mkdir -p "$PREVIEWS_DIR"
    mkdir -p "$APPROVALS_DIR"
}

# Generate unique preview ID
generate_preview_id() {
    echo "preview_$(date +%Y%m%d_%H%M%S)_$$"
}

# Assess risk level of proposed action
assess_risk_level() {
    local action_type="$1"
    local action_content="$2"
    local context="${3:-}"

    log "Assessing risk level for action: $action_type"

    local risk_score=0
    local risk_factors=()

    # File system operations
    if [[ "$action_type" =~ ^(create|modify|delete)_file$ ]]; then
        risk_score=$((risk_score + 3))
        risk_factors+=("file_system_modification")

        # Check if it's a critical file
        if [[ "$action_content" =~ (\.env|config\.json|\.ssh/|Cargo\.toml|package\.json) ]]; then
            risk_score=$((risk_score + 5))
            risk_factors+=("critical_file")
        fi
    fi

    # Network operations
    if [[ "$action_type" =~ ^(http_|network|api)_ ]]; then
        risk_score=$((risk_score + 4))
        risk_factors+=("network_access")

        # External API calls
        if [[ "$action_content" =~ (api\.github\.com|api\.gitlab\.com|openrouter\.ai) ]]; then
            risk_score=$((risk_score + 2))
            risk_factors+=("external_api")
        fi
    fi

    # Code execution
    if [[ "$action_type" =~ ^(execute|run|compile) ]]; then
        risk_score=$((risk_score + 6))
        risk_factors+=("code_execution")

        # Check for potentially dangerous operations
        if [[ "$action_content" =~ (rm -rf|sudo|chmod 777|eval|exec) ]]; then
            risk_score=$((risk_score + 8))
            risk_factors+=("dangerous_commands")
        fi
    fi

    # Large scale operations
    if [[ "$action_content" =~ (find|grep -r|rm|mv|cp).*\.\./ ]]; then
        risk_score=$((risk_score + 4))
        risk_factors+=("bulk_operations")
    fi

    # Determine risk level
    local risk_level
    if [[ $risk_score -ge 15 ]]; then
        risk_level="critical"
    elif [[ $risk_score -ge 10 ]]; then
        risk_level="high"
    elif [[ $risk_score -ge 5 ]]; then
        risk_level="medium"
    else
        risk_level="low"
    fi

    # Create risk assessment
    local assessment_file="$PREVIEWS_DIR/risk_assessment_$(date +%Y%m%d_%H%M%S).json"

    cat > "$assessment_file" << EOF
{
  "assessment_id": "$(basename "$assessment_file" .json)",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "action_type": "$action_type",
  "risk_score": $risk_score,
  "risk_level": "$risk_level",
  "risk_factors": $(printf '%s\n' "${risk_factors[@]}" | jq -R . | jq -s .),
  "assessment_criteria": {
    "file_system_risk": $(echo "$action_content" | grep -c -E "(create|modify|delete)_file"),
    "network_risk": $(echo "$action_content" | grep -c -E "(http|network|api)"),
    "execution_risk": $(echo "$action_content" | grep -c -E "(execute|run|compile)"),
    "scope_risk": $(echo "$action_content" | grep -c -E "(\.\./|\.\*)")
  },
  "recommendations": [
    "$risk_level" == "critical" ? "Require human approval before execution" : "Auto-approve allowed",
    "Monitor execution closely",
    "Have rollback plan ready"
  ]
}
EOF

    success "Risk assessment completed: $risk_level (score: $risk_score)"
    echo "$risk_level"
}

# Create preview of proposed action
create_preview() {
    local action_type="$1"
    local action_content="$2"
    local context="$3"
    local risk_level="$4"

    local preview_id
    preview_id=$(generate_preview_id)

    log "Creating preview for action: $action_type (risk: $risk_level)"

    local preview_file="$PREVIEWS_DIR/${preview_id}.json"

    # Get risk level properties
    IFS=':' read -r risk_icon risk_description auto_approve_timeout max_wait_time <<< "${RISK_LEVELS[$risk_level]}"

    # Create comprehensive preview
    cat > "$preview_file" << EOF
{
  "preview_id": "$preview_id",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "action_type": "$action_type",
  "risk_level": "$risk_level",
  "risk_assessment": "$risk_description",
  "status": "pending_approval",
  "auto_approve_timeout_seconds": ${auto_approve_timeout:-0},
  "max_wait_time_seconds": "${max_wait_time:-infinite}",

  "proposed_action": {
    "type": "$action_type",
    "content": "$action_content",
    "context": "$context",
    "estimated_impact": "$(estimate_impact "$action_type" "$action_content")",
    "reversibility": "$(assess_reversibility "$action_type" "$action_content")"
  },

  "safety_gates": {
    "ask_act_gate": $(evaluate_ask_act_gate "$action_type" "$context"),
    "evidence_gate": $(evaluate_evidence_gate "$action_type" "$action_content"),
    "caps_gate": $(evaluate_caps_gate "$action_type" "$risk_level"),
    "freshness_gate": $(evaluate_freshness_gate "$context")
  },

  "preview_details": {
    "files_to_be_created": $(list_files_to_create "$action_content"),
    "files_to_be_modified": $(list_files_to_modify "$action_content"),
    "files_to_be_deleted": $(list_files_to_delete "$action_content"),
    "commands_to_execute": $(list_commands_to_execute "$action_content"),
    "network_calls": $(list_network_calls "$action_content")
  },

  "approval_requirements": {
    "human_approval_required": $([[ "$risk_level" =~ ^(high|critical)$ ]] && echo "true" || echo "false"),
    "auto_approve_allowed": $([[ "$risk_level" == "low" ]] && echo "true" || echo "false"),
    "minimum_approvers": $([[ "$risk_level" == "critical" ]] && echo "2" || echo "1"),
    "approval_timeout": "${auto_approve_timeout:-0}s"
  },

  "rollback_plan": {
    "rollback_possible": $(assess_rollback_possibility "$action_type"),
    "rollback_complexity": "$(get_rollback_complexity "$action_type")",
    "estimated_rollback_time_seconds": $(estimate_rollback_time "$action_type"),
    "rollback_prerequisites": $(list_rollback_prerequisites "$action_type")
  },

  "monitoring_plan": {
    "metrics_to_monitor": ["execution_time", "error_rate", "resource_usage"],
    "alert_thresholds": {
      "max_execution_time": "300s",
      "max_error_rate": "0.1",
      "max_memory_usage": "1GB"
    },
    "rollback_triggers": [
      "execution_time_exceeded",
      "error_rate_too_high",
      "unexpected_file_changes"
    ]
  }
}
EOF

    success "Preview created: $preview_file"
    echo "$preview_id"
}

# Estimate impact of action
estimate_impact() {
    local action_type="$1"
    local action_content="$2"

    # Simple impact estimation based on action type and scope
    case "$action_type" in
        "create_file")
            echo "Creates new file or directory"
            ;;
        "modify_file")
            echo "Modifies existing file content"
            ;;
        "delete_file")
            echo "Removes file or directory (potentially destructive)"
            ;;
        "execute_command")
            echo "Runs system command with potential side effects"
            ;;
        "network_request")
            echo "Makes network call to external service"
            ;;
        "install_package")
            echo "Installs software package (system changes)"
            ;;
        *)
            echo "Unknown impact - requires manual assessment"
            ;;
    esac
}

# Assess reversibility of action
assess_reversibility() {
    local action_type="$1"
    local action_content="$2"

    case "$action_type" in
        "create_file")
            echo "high"  # Easy to delete created files
            ;;
        "modify_file")
            echo "medium"  # May need git revert or backups
            ;;
        "delete_file")
            echo "low"  # May lose data permanently
            ;;
        "execute_command")
            echo "varies"  # Depends on command
            ;;
        "install_package")
            echo "medium"  # Can usually be uninstalled
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# Evaluate safety gates
evaluate_ask_act_gate() {
    local action_type="$1"
    local context="$2"

    # Simplified evaluation - in real implementation would check alignment bits
    case "$action_type" in
        "create_file"|"modify_file")
            echo "true"  # Generally safe for file operations
            ;;
        "delete_file")
            echo "false"  # Deletion requires explicit permission
            ;;
        "execute_command")
            echo "false"  # Command execution requires permission
            ;;
        *)
            echo "true"
            ;;
    esac
}

evaluate_evidence_gate() {
    local action_type="$1"
    local action_content="$2"

    # Check if we have sufficient evidence for this action
    if [[ -n "$action_content" ]]; then
        echo "true"
    else
        echo "false"
    fi
}

evaluate_caps_gate() {
    local action_type="$1"
    local risk_level="$2"

    # Caps gate: sensitive operations need human approval
    if [[ "$risk_level" =~ ^(high|critical)$ ]]; then
        echo "false"  # Requires human approval
    else
        echo "true"  # Auto-approve allowed
    fi
}

evaluate_freshness_gate() {
    local context="$1"

    # Check if context is current (simplified)
    echo "true"  # Assume context is fresh unless we know otherwise
}

# List files that would be created
list_files_to_create() {
    local action_content="$1"

    # Extract file paths from action content (simplified)
    echo "[]"  # Would parse actual file creation operations
}

# List files that would be modified
list_files_to_modify() {
    local action_content="$1"

    echo "[]"  # Would parse actual file modification operations
}

# List files that would be deleted
list_files_to_delete() {
    local action_content="$1"

    echo "[]"  # Would parse actual file deletion operations
}

# List commands that would be executed
list_commands_to_execute() {
    local action_content="$1"

    # Extract command patterns (simplified)
    if [[ "$action_content" =~ (curl|wget|git|npm|pip|cargo|make) ]]; then
        echo "[\"$action_content\"]"
    else
        echo "[]"
    fi
}

# List network calls that would be made
list_network_calls() {
    local action_content="$1"

    # Extract network patterns (simplified)
    if [[ "$action_content" =~ (http://|https://|api\.) ]]; then
        echo "[\"$action_content\"]"
    else
        echo "[]"
    fi
}

# Assess rollback possibility
assess_rollback_possibility() {
    local action_type="$1"

    case "$action_type" in
        "create_file")
            echo "true"
            ;;
        "modify_file")
            echo "true"  # Git revert usually possible
            ;;
        "delete_file")
            echo "false"  # May not be recoverable
            ;;
        "execute_command")
            echo "false"  # Commands may not be reversible
            ;;
        *)
            echo "true"
            ;;
    esac
}

# Get rollback complexity
get_rollback_complexity() {
    local action_type="$1"

    case "$action_type" in
        "create_file")
            echo "low"
            ;;
        "modify_file")
            echo "medium"
            ;;
        "delete_file")
            echo "high"
            ;;
        "execute_command")
            echo "high"
            ;;
        *)
            echo "medium"
            ;;
    esac
}

# Estimate rollback time
estimate_rollback_time() {
    local action_type="$1"

    case "$action_type" in
        "create_file")
            echo "10"
            ;;
        "modify_file")
            echo "30"
            ;;
        "delete_file")
            echo "300"
            ;;
        "execute_command")
            echo "600"
            ;;
        *)
            echo "60"
            ;;
    esac
}

# List rollback prerequisites
list_rollback_prerequisites() {
    local action_type="$1"

    case "$action_type" in
        "create_file")
            echo "[\"file_system_access\"]"
            ;;
        "modify_file")
            echo "[\"git_repository\", \"backup_available\"]"
            ;;
        "delete_file")
            echo "[\"backup_available\", \"version_control\"]"
            ;;
        "execute_command")
            echo "[\"system_restore\", \"backup_available\"]"
            ;;
        *)
            echo "[\"manual_intervention\"]"
            ;;
    esac
}

# Show preview details
show_preview() {
    local preview_id="$1"

    local preview_file="$PREVIEWS_DIR/${preview_id}.json"

    if [[ ! -f "$preview_file" ]]; then
        error "Preview not found: $preview_id"
    fi

    echo -e "${CYAN}Preview Details: $preview_id${NC}"
    echo "==========================="

    # Show key preview information
    local action_type
    local risk_level
    local status
    local created_at

    action_type=$(jq -r '.action_type' "$preview_file")
    risk_level=$(jq -r '.risk_level' "$preview_file")
    status=$(jq -r '.status' "$preview_file")
    created_at=$(jq -r '.created_at' "$preview_file")

    echo "Action Type: $action_type"
    echo "Risk Level: $risk_level"
    echo "Status: $status"
    echo "Created: $created_at"
    echo ""

    # Show proposed action
    echo "Proposed Action:"
    jq '.proposed_action' "$preview_file"
    echo ""

    # Show safety gates
    echo "Safety Gates:"
    jq '.safety_gates' "$preview_file"
    echo ""

    # Show approval requirements
    echo "Approval Requirements:"
    jq '.approval_requirements' "$preview_file"
    echo ""

    # Show rollback plan
    echo "Rollback Plan:"
    jq '.rollback_plan' "$preview_file"
}

# Approve preview for execution
approve_preview() {
    local preview_id="$1"
    local approver="${2:-system}"

    local preview_file="$PREVIEWS_DIR/${preview_id}.json"

    if [[ ! -f "$preview_file" ]]; then
        error "Preview not found: $preview_id"
    fi

    # Check if already approved
    local current_status
    current_status=$(jq -r '.status' "$preview_file")

    if [[ "$current_status" == "approved" ]]; then
        warning "Preview already approved"
        return 0
    fi

    # Check risk level and approval requirements
    local risk_level
    local human_approval_required

    risk_level=$(jq -r '.risk_level' "$preview_file")
    human_approval_required=$(jq -r '.approval_requirements.human_approval_required' "$preview_file")

    if [[ "$human_approval_required" == "true" ]] && [[ "$approver" != "human" ]]; then
        error "Human approval required for high-risk action (risk level: $risk_level)"
    fi

    # Create approval record
    local approval_id="approval_$(date +%Y%m%d_%H%M%S)_$$"
    local approval_file="$APPROVALS_DIR/${approval_id}.json"

    cat > "$approval_file" << EOF
{
  "approval_id": "$approval_id",
  "preview_id": "$preview_id",
  "approved_by": "$approver",
  "approved_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "risk_level": "$risk_level",
  "approval_type": "$([[ "$human_approval_required" == "true" ]] && echo "human" || echo "automatic")",
  "approval_criteria": [
    "Safety gates passed",
    "Risk level acceptable",
    "Rollback plan available",
    "Monitoring plan in place"
  ],
  "execution_conditions": {
    "max_execution_time": "$(jq -r '.monitoring_plan.alert_thresholds.max_execution_time' "$preview_file")",
    "rollback_triggers": $(jq '.monitoring_plan.rollback_triggers' "$preview_file"),
    "success_criteria": ["completion_without_errors", "rollback_plan_verified"]
  }
}
EOF

    # Update preview status
    jq --arg approval_id "$approval_id" \
       --arg approver "$approver" \
       '.status = "approved" | .approved_by = $approver | .approval_id = $approval_id' \
       "$preview_file" > "${preview_file}.tmp"

    mv "${preview_file}.tmp" "$preview_file"

    success "Preview approved: $preview_id (approval: $approval_id)"
    echo "$approval_id"
}

# Reject preview
reject_preview() {
    local preview_id="$1"
    local reason="${2:-No reason provided}"
    local rejector="${3:-system}"

    local preview_file="$PREVIEWS_DIR/${preview_id}.json"

    if [[ ! -f "$preview_file" ]]; then
        error "Preview not found: $preview_id"
    fi

    # Update preview status
    jq --arg reason "$reason" \
       --arg rejector "$rejector" \
       '.status = "rejected" | .rejected_by = $rejector | .rejection_reason = $reason' \
       "$preview_file" > "${preview_file}.tmp"

    mv "${preview_file}.tmp" "$preview_file"

    success "Preview rejected: $preview_id (reason: $reason)"
}

# Execute approved preview
execute_approved_preview() {
    local preview_id="$1"

    local preview_file="$PREVIEWS_DIR/${preview_id}.json"

    if [[ ! -f "$preview_file" ]]; then
        error "Preview not found: $preview_id"
    fi

    # Check if approved
    local status
    status=$(jq -r '.status' "$preview_file")

    if [[ "$status" != "approved" ]]; then
        error "Preview not approved for execution (status: $status)"
    fi

    log "Executing approved preview: $preview_id"

    # Get action details
    local action_type
    local action_content

    action_type=$(jq -r '.proposed_action.type' "$preview_file")
    action_content=$(jq -r '.proposed_action.content' "$preview_file")

    # Execute based on action type (simplified)
    local execution_result="success"
    local execution_error=""

    case "$action_type" in
        "create_file")
            # Create file with content
            if echo "$action_content" | grep -q "file:"; then
                # Extract file path and content (simplified)
                execution_result="success"
            else
                execution_result="failed"
                execution_error="Invalid file creation format"
            fi
            ;;
        "modify_file")
            # Modify existing file
            execution_result="success"
            ;;
        "execute_command")
            # Execute shell command
            if eval "$action_content" 2>/dev/null; then
                execution_result="success"
            else
                execution_result="failed"
                execution_error="Command execution failed"
            fi
            ;;
        *)
            execution_result="failed"
            execution_error="Unknown action type: $action_type"
            ;;
    esac

    # Update preview with execution results
    jq --arg result "$execution_result" \
       --arg error_msg "$execution_error" \
       --arg executed_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
       '.execution_result = $result | .execution_error = $error_msg | .executed_at = $executed_at' \
       "$preview_file" > "${preview_file}.tmp"

    mv "${preview_file}.tmp" "$preview_file"

    if [[ "$execution_result" == "success" ]]; then
        success "Preview executed successfully: $preview_id"
    else
        error "Preview execution failed: $preview_id (error: $execution_error)"
    fi
}

# Monitor pending previews
monitor_pending_previews() {
    echo -e "${CYAN}Pending Previews${NC}"
    echo "================"

    local pending_count=0

    # Find all pending previews
    while IFS= read -r -d '' preview_file; do
        if [[ -f "$preview_file" ]]; then
            local status
            local preview_id
            local risk_level
            local created_at
            local action_type

            status=$(jq -r '.status' "$preview_file")
            preview_id=$(jq -r '.preview_id' "$preview_file")
            risk_level=$(jq -r '.risk_level' "$preview_file")
            created_at=$(jq -r '.created_at' "$preview_file")
            action_type=$(jq -r '.action_type' "$preview_file")

            if [[ "$status" == "pending_approval" ]]; then
                pending_count=$((pending_count + 1))

                # Get risk level properties
                IFS=':' read -r risk_icon risk_description _ _ <<< "${RISK_LEVELS[$risk_level]}"

                echo "$pending_count. $risk_icon $preview_id"
                echo "   Action: $action_type"
                echo "   Risk: $risk_level"
                echo "   Created: $created_at"
                echo "   Command: ./bin/preview approve $preview_id"
                echo ""
            fi
        fi
    done < <(find "$PREVIEWS_DIR" -name "*.json" -print0 2>/dev/null)

    if [[ $pending_count -eq 0 ]]; then
        echo "No pending previews"
    else
        echo "Total pending: $pending_count"
    fi
}

# Main command dispatcher
main() {
    # Create log file
    mkdir -p "$(dirname "$LOG_FILE")"
    touch "$LOG_FILE"

    setup_preview_directories

    local cmd="${1:-status}"

    case "$cmd" in
        "preview")
            shift
            local action_type="${1:-}"
            local action_content="${2:-}"
            local context="${3:-}"

            if [[ -z "$action_type" || -z "$action_content" ]]; then
                error "Action type and content required for preview"
            fi

            # Assess risk and create preview
            local risk_level
            risk_level=$(assess_risk_level "$action_type" "$action_content" "$context")

            local preview_id
            preview_id=$(create_preview "$action_type" "$action_content" "$context" "$risk_level")

            echo "Preview created: $preview_id"
            echo "Risk level: $risk_level"
            show_preview "$preview_id"
            ;;
        "approve")
            shift
            local preview_id="$1"

            if [[ -z "$preview_id" ]]; then
                error "Preview ID required for approval"
            fi

            approve_preview "$preview_id" "human"
            ;;
        "reject")
            shift
            local preview_id="$1"
            local reason="${2:-No reason provided}"

            if [[ -z "$preview_id" ]]; then
                error "Preview ID required for rejection"
            fi

            reject_preview "$preview_id" "$reason" "human"
            ;;
        "execute")
            shift
            local preview_id="$1"

            if [[ -z "$preview_id" ]]; then
                error "Preview ID required for execution"
            fi

            execute_approved_preview "$preview_id"
            ;;
        "status")
            monitor_pending_previews
            ;;
        "list")
            echo -e "${CYAN}All Previews${NC}"
            echo "============"

            find "$PREVIEWS_DIR" -name "*.json" | while IFS= read -r preview_file; do
                local preview_id
                local status
                local risk_level
                local action_type

                preview_id=$(basename "$preview_file" .json)
                status=$(jq -r '.status' "$preview_file")
                risk_level=$(jq -r '.risk_level' "$preview_file")
                action_type=$(jq -r '.action_type' "$preview_file")

                # Get risk level icon
                IFS=':' read -r risk_icon _ _ _ <<< "${RISK_LEVELS[$risk_level]}"

                echo "$risk_icon $preview_id ($status)"
                echo "   $action_type - Risk: $risk_level"
            done
            ;;
        "help"|"-h"|"--help")
            cat << EOF
Previewâ‰¤Apply Safety Model - Preview all actions before execution

USAGE:
    $0 [COMMAND] [ARGUMENTS]

COMMANDS:
    preview <type> <content> [context]    Create preview of proposed action
    approve <preview_id>                  Approve preview for execution
    reject <preview_id> [reason]          Reject preview
    execute <preview_id>                  Execute approved preview
    status                                Show pending previews
    list                                  List all previews

EXAMPLES:
    $0 preview "create_file" "echo 'hello' > test.txt" "Creating test file"
    $0 approve preview_20241230_123456_12345
    $0 execute preview_20241230_123456_12345
    $0 status                              # Show what needs approval

SAFETY MODEL:
    Preview â‰¤ Apply - All actions must be previewed before execution

    Risk Levels:
    ðŸŸ¢ LOW     - Safe operations (file reads, simple queries)
    ðŸŸ¡ MEDIUM  - Moderate risk (file writes, internal APIs)
    ðŸŸ  HIGH    - High risk (deletions, external APIs)
    ðŸ”´ CRITICAL - Critical risk (system changes, destructive ops)

    Safety Gates:
    - Ask/Act Gate: Execute only if A==1 âˆ§ P==1 âˆ§ Î”==0
    - Evidence Gate: If U==1, gather evidence before T==1
    - Caps Gate: Sensitive caps require P==1 with human preview
    - Freshness Gate: If Î”==1, re-ground context before acting

APPROVAL WORKFLOW:
    1. Create preview of proposed action
    2. Risk assessment determines approval requirements
    3. Human approval for high/critical risk actions
    4. Auto-approval for low risk actions (with timeout)
    5. Execute only after approval
    6. Monitor execution and rollback if needed

FILES:
    deliverables/previews/                 # Preview records
    deliverables/approvals/                # Approval records
    deliverables/preview.log               # Operation log

INTEGRATION:
    - Works with taskflow for recursive execution
    - Compatible with proof system for receipts
    - Supports all One Engine operations
    - Enforces governance policies
EOF
            ;;
        *)
            error "Unknown command: $cmd. Use 'help' for usage information."
            ;;
    esac
}

# Run main function with all arguments
main "$@"