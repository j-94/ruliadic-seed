#!/bin/bash
# Graphlogue v2.0 - Live streaming graph with fuzzy search and recommendations
# Usage: ./bin/graphlogue [view|stream|search|recommend]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
GRAPH_DIR="$SCRIPT_DIR/graph"
NODES_FILE="$GRAPH_DIR/nodes.tsv"
EDGES_FILE="$GRAPH_DIR/edges.tsv"
SSE_FILE="$GRAPH_DIR/events.sse"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Utility functions
log() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')] $1${NC}"
}

success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

error() {
    echo -e "${RED}‚ùå $1${NC}"
    exit 1
}

# Create directories
setup_directories() {
    mkdir -p "$GRAPH_DIR"
    touch "$NODES_FILE"
    touch "$EDGES_FILE"
    touch "$SSE_FILE"
}

# Stream SSE events to graph
stream_events() {
    log "Starting event streaming to graph..."

    # Start SSE server in background
    while true; do
        # Read from SSE file and process events
        if [[ -f "$SSE_FILE" ]]; then
            tail -f "$SSE_FILE" | while IFS= read -r line; do
                if [[ "$line" =~ ^data:\ (.+)$ ]]; then
                    event_data="${BASH_REMATCH[1]}"
                    process_event "$event_data"
                fi
            done
        fi
        sleep 1
    done
}

# Process incoming event
process_event() {
    local event_data="$1"

    # Parse event data (expecting JSON)
    local event_type
    local event_id
    local event_timestamp

    # Extract basic event information
    event_type=$(echo "$event_data" | grep -o '"event_type":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
    event_id=$(echo "$event_data" | grep -o '"id":"[^"]*"' | cut -d'"' -f4 || echo "$(date +%s)")
    event_timestamp=$(echo "$event_data" | grep -o '"timestamp":"[^"]*"' | cut -d'"' -f4 || echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)")

    # Add node for this event
    add_node "$event_id" "$event_type" "$event_timestamp"

    # Look for related events to create edges
    create_edges "$event_id" "$event_type" "$event_data"

    log "Processed event: $event_type ($event_id)"
}

# Add node to graph
add_node() {
    local node_id="$1"
    local node_type="$2"
    local timestamp="$3"

    # Check if node already exists
    if grep -q "^${node_id}" "$NODES_FILE"; then
        # Update existing node
        sed -i.bak "s/^${node_id}.*/${node_id}\t${node_type}\t${timestamp}/" "$NODES_FILE"
    else
        # Add new node
        echo -e "${node_id}\t${node_type}\t${timestamp}" >> "$NODES_FILE"
    fi
}

# Create edges between related nodes
create_edges() {
    local node_id="$1"
    local node_type="$2"
    local event_data="$3"

    # Find related nodes based on event type and data
    case "$node_type" in
        "task_started")
            # Link to parent task if mentioned
            local parent_id
            parent_id=$(echo "$event_data" | grep -o '"parent_task":"[^"]*"' | cut -d'"' -f4 || echo "")
            if [[ -n "$parent_id" ]] && grep -q "^${parent_id}" "$NODES_FILE"; then
                add_edge "$parent_id" "$node_id" "triggers"
            fi
            ;;
        "task_completed")
            # Link to corresponding task_started event
            if grep -q "task_started.*${node_id}" "$NODES_FILE"; then
                add_edge "$(grep "task_started.*${node_id}" "$NODES_FILE" | cut -f1)" "$node_id" "completes"
            fi
            ;;
        "code_generated")
            # Link to generation request
            local request_id
            request_id=$(echo "$event_data" | grep -o '"request_id":"[^"]*"' | cut -d'"' -f4 || echo "")
            if [[ -n "$request_id" ]]; then
                add_edge "$request_id" "$node_id" "generates"
            fi
            ;;
        "pattern_detected")
            # Link to source analysis
            local source_id
            source_id=$(echo "$event_data" | grep -o '"source_id":"[^"]*"' | cut -d'"' -f4 || echo "")
            if [[ -n "$source_id" ]]; then
                add_edge "$source_id" "$node_id" "detects"
            fi
            ;;
    esac
}

# Add edge to graph
add_edge() {
    local from_node="$1"
    local to_node="$2"
    local edge_type="$3"

    # Check if edge already exists
    if ! grep -q "^${from_node}->${to_node}" "$EDGES_FILE"; then
        echo -e "${from_node}->${to_node}\t${edge_type}" >> "$EDGES_FILE"
    fi
}

# View graph with fzf
view_graph() {
    log "Opening interactive graph viewer..."

    # Check if fzf is available
    if ! command -v fzf &> /dev/null; then
        error "fzf is required for graph viewing. Install it first: brew install fzf"
    fi

    # Create temporary files for fzf
    local temp_nodes="/tmp/graphlogue_nodes_$$"
    local temp_edges="/tmp/graphlogue_edges_$$"

    cp "$NODES_FILE" "$temp_nodes"
    cp "$EDGES_FILE" "$temp_edges"

    # Main viewing loop
    while true; do
        echo -e "${CYAN}Graphlogue v2.0 - Interactive Graph Viewer${NC}"
        echo "=========================================="
        echo ""

        # Show node selection menu
        local selected_node
        selected_node=$(cat "$temp_nodes" | cut -f1,2 | nl | \
            fzf --prompt="Select node to explore: " \
                --header="Node ID | Type" \
                --preview="echo 'Node details:'; grep \"^{$(( $(echo {} | cut -d' ' -f1) ))}\" \"$temp_nodes\" | cut -f2-" \
                --preview-window=up:3 \
                --bind="ctrl-r:reload(cat \"$temp_nodes\" | cut -f1,2 | nl)" \
                --bind="ctrl-s:execute(grep \"^{$(( $(echo {} | cut -d' ' -f1) ))}\" \"$temp_nodes\" | cut -f1 > /tmp/selected_node_$$)" \
                --height=50% \
                --reverse \
                | cut -d' ' -f2- | cut -d$'\t' -f1)

        if [[ -z "$selected_node" ]]; then
            break
        fi

        show_node_details "$selected_node"
        echo ""
        echo -n "Press Enter to continue, 'q' to quit: "
        read -r choice

        if [[ "$choice" == "q" ]]; then
            break
        fi
    done

    # Cleanup
    rm -f "$temp_nodes" "$temp_edges"
}

# Show detailed node information
show_node_details() {
    local node_id="$1"

    echo -e "${CYAN}Node Details: $node_id${NC}"
    echo "=================="

    # Show node information
    local node_info
    node_info=$(grep "^${node_id}" "$NODES_FILE")
    if [[ -n "$node_info" ]]; then
        IFS=$'\t' read -r id type timestamp <<< "$node_info"
        echo "ID: $id"
        echo "Type: $type"
        echo "Timestamp: $timestamp"
    fi

    # Show connected edges
    echo ""
    echo "Connections:"
    grep "${node_id}" "$EDGES_FILE" | while IFS=$'\t' read -r edge_info; do
        local from_to
        local edge_type
        IFS=$'\t' read -r from_to edge_type <<< "$edge_info"
        if [[ "$from_to" =~ ^(.*)->(.*)$ ]]; then
            local from_node="${BASH_REMATCH[1]}"
            local to_node="${BASH_REMATCH[2]}"

            if [[ "$from_node" == "$node_id" ]]; then
                echo "  ‚Üí $to_node ($edge_type)"
            elif [[ "$to_node" == "$node_id" ]]; then
                echo "  ‚Üê $from_node ($edge_type)"
            fi
        fi
    done
}

# Fuzzy search through graph
search_graph() {
    log "Fuzzy search through graph..."

    if [[ -z "${1:-}" ]]; then
        echo "Usage: $0 search <query>"
        echo "Examples:"
        echo "  $0 search 'codex'"
        echo "  $0 search 'error'"
        echo "  $0 search 'pattern'"
        exit 1
    fi

    local query="$1"

    echo -e "${CYAN}Search Results for: $query${NC}"
    echo "=========================="

    # Search in nodes
    echo ""
    echo "Nodes:"
    grep -i "$query" "$NODES_FILE" | while IFS=$'\t' read -r node_id node_type timestamp; do
        echo "  üìÑ $node_id ($node_type) - $timestamp"
    done

    # Search in edges
    echo ""
    echo "Edges:"
    grep -i "$query" "$EDGES_FILE" | while IFS=$'\t' read -r edge_info; do
        echo "  üîó $edge_info"
    done

    # Show statistics
    local node_count
    local edge_count
    node_count=$(grep -i "$query" "$NODES_FILE" | wc -l)
    edge_count=$(grep -i "$query" "$EDGES_FILE" | wc -l)

    echo ""
    echo "Statistics:"
    echo "  Nodes matching: $node_count"
    echo "  Edges matching: $edge_count"
}

# Generate recommendations
generate_recommendations() {
    log "Generating recommendations..."

    echo -e "${CYAN}Graph-based Recommendations${NC}"
    echo "=========================="

    # Analyze patterns and suggest next steps
    local recent_nodes
    recent_nodes=$(tail -10 "$NODES_FILE")

    echo "Based on recent activity:"
    echo ""

    if echo "$recent_nodes" | grep -q "codex"; then
        echo "üî• Hot: Codex activity detected"
        echo "  ‚Üí Try: ./bin/codex 'your next coding task'"
        echo "  ‚Üí Review: Check editor-integrations.vim for vim integration"
    fi

    if echo "$recent_nodes" | grep -q "pattern"; then
        echo "üîç Pattern mining active"
        echo "  ‚Üí Run: ./bin/mine_experiences.sh all"
        echo "  ‚Üí Explore: Check patterns/ directory for discovered patterns"
    fi

    if echo "$recent_nodes" | grep -q "task"; then
        echo "‚ö° Task execution in progress"
        echo "  ‚Üí Monitor: ./bin/tau status"
        echo "  ‚Üí View: ls -la receipts/ for execution history"
    fi

    # General recommendations
    echo ""
    echo "General suggestions:"
    echo "  üìä View KPIs: ./bin/doctor"
    echo "  üîß Check health: ./bin/ping"
    echo "  üìñ Read docs: cat TASK_PLAYBOOK.md"
    echo "  üöÄ Quick start: ./bin/tau fiveline"
}

# Show graph statistics
show_stats() {
    local node_count
    local edge_count
    local node_types
    local recent_activity

    node_count=$(wc -l < "$NODES_FILE")
    edge_count=$(wc -l < "$EDGES_FILE")
    node_types=$(cut -f2 "$NODES_FILE" | sort | uniq -c | sort -nr)
    recent_activity=$(tail -5 "$NODES_FILE")

    echo -e "${CYAN}Graph Statistics${NC}"
    echo "================"
    echo "Nodes: $node_count"
    echo "Edges: $edge_count"
    echo ""
    echo "Node types:"
    echo "$node_types"
    echo ""
    echo "Recent activity:"
    echo "$recent_activity"
}

# Main command dispatcher
main() {
    setup_directories

    local cmd="${1:-view}"

    case "$cmd" in
        "view")
            view_graph
            ;;
        "stream")
            stream_events
            ;;
        "search")
            search_graph "${2:-}"
            ;;
        "recommend")
            generate_recommendations
            ;;
        "stats")
            show_stats
            ;;
        "help"|"-h"|"--help")
            cat << EOF
Graphlogue v2.0 - Live streaming graph with fuzzy search

USAGE:
    $0 [COMMAND] [ARGUMENTS]

COMMANDS:
    view                    Interactive graph viewer with fzf
    stream                  Stream SSE events to graph (runs continuously)
    search <query>          Fuzzy search through nodes and edges
    recommend               Generate recommendations based on graph
    stats                   Show graph statistics and recent activity

EXAMPLES:
    $0 view                 # Interactive graph exploration
    $0 search "codex"       # Search for codex-related nodes
    $0 recommend            # Get AI-powered recommendations
    $0 stats                # View graph statistics

REQUIREMENTS:
    - fzf (for interactive viewing)
    - bash 4.0+ (for associative arrays)
    - curl (for SSE processing)

FILES:
    graph/nodes.tsv         # Graph nodes (id, type, timestamp)
    graph/edges.tsv         # Graph edges (from->to, type)
    graph/events.sse        # SSE event stream

SHORTCUTS:
    ./bin/graphlogue view   # Quick access to viewer
    ./bin/graphlogue search "pattern"  # Find patterns
    ./bin/graphlogue recommend         # Get suggestions

The graph automatically builds as events stream in from:
- Task executions
- Code generation
- Pattern discoveries
- System events
EOF
            ;;
        *)
            error "Unknown command: $cmd. Use 'help' for usage information."
            ;;
    esac
}

# Handle script interruption
trap 'echo -e "\n${YELLOW}Graphlogue interrupted${NC}"; exit 0' INT

# Run main function with all arguments
main "$@"